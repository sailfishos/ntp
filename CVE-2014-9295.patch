Description: fix buffer overflows in crypto_recv() and ctl_putdata()
Origin: backport, http://bk1.ntp.org/ntp-dev/?PAGE=patch&REV=548acc4dN1TbM1tRJrbPcA4yc1aTdA
Origin: backport, http://bk1.ntp.org/ntp-dev/?PAGE=patch&REV=548acdf3tUSFizXcv_X4b77Jt_Y-cg
Bug: http://bugs.ntp.org/show_bug.cgi?id=2667
Bug: http://bugs.ntp.org/show_bug.cgi?id=2668

Index: ntp-4.2.4p8+dfsg/ntpd/ntp_control.c
===================================================================
--- ntp-4.2.4p8+dfsg.orig/ntpd/ntp_control.c	2014-12-20 06:22:11.505860832 -0500
+++ ntp-4.2.4p8+dfsg/ntpd/ntp_control.c	2014-12-20 06:22:11.501860797 -0500
@@ -473,6 +473,10 @@
 static	char *reqpt;
 static	char *reqend;
 
+#ifndef MIN
+#define MIN(a, b) (((a) <= (b)) ? (a) : (b))
+#endif
+
 /*
  * init_control - initialize request data
  */
@@ -888,6 +892,7 @@
 	)
 {
 	int overhead;
+	unsigned int currentlen;
 
 	overhead = 0;
 	if (!bin) {
@@ -911,12 +916,22 @@
 	/*
 	 * Save room for trailing junk
 	 */
-	if (dlen + overhead + datapt > dataend) {
+	while (dlen + overhead + datapt > dataend) {
 		/*
 		 * Not enough room in this one, flush it out.
 		 */
+		currentlen = MIN(dlen, dataend - datapt);
+
+		memcpy(datapt, dp, currentlen);
+
+		datapt += currentlen;
+		dp += currentlen;
+		dlen -= currentlen;
+		datalinelen += currentlen;
+
 		ctl_flushpkt(CTL_MORE);
 	}
+
 	memmove((char *)datapt, dp, (unsigned)dlen);
 	datapt += dlen;
 	datalinelen += dlen;
Index: ntp-4.2.4p8+dfsg/ntpd/ntp_crypto.c
===================================================================
--- ntp-4.2.4p8+dfsg.orig/ntpd/ntp_crypto.c	2014-12-20 06:22:11.505860832 -0500
+++ ntp-4.2.4p8+dfsg/ntpd/ntp_crypto.c	2014-12-20 06:27:18.076523398 -0500
@@ -864,12 +864,25 @@
 			 * errors.
 			 */
 			if (vallen == (u_int) EVP_PKEY_size(host_pkey)) {
-				RSA_private_decrypt(vallen,
+				u_int32 *cookiebuf = malloc(
+				    RSA_size(host_pkey->pkey.rsa));
+				if (!cookiebuf) {
+					rval = XEVNT_CKY;
+					break;
+				}
+
+				if (RSA_private_decrypt(vallen,
 				    (u_char *)ep->pkt,
-				    (u_char *)&temp32,
+				    (u_char *)cookiebuf,
 				    host_pkey->pkey.rsa,
-				    RSA_PKCS1_OAEP_PADDING);
-				cookie = ntohl(temp32);
+				    RSA_PKCS1_OAEP_PADDING) != 4) {
+ 					rval = XEVNT_CKY;
+					free(cookiebuf);
+ 					break;
+ 				} else {
+					cookie = ntohl(*cookiebuf);
+					free(cookiebuf);
+ 				}
 			} else {
 				rval = XEVNT_CKY;
 				break;
